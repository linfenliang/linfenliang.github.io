---
layout: post
title:  "JAVA虚拟机类加载机制"
subtitle: "JVM中类加载的时机、过程与类加载器"
author: "linfenliang"
date:   2017-10-15
header-img: "img/post-bg-tech.jpg"
catalog:    true
tags:
    - 学习
    - JVM
categories: JVM
---


# 概述
 Java编译器将.java文件编译成.class文件后，虚拟机需要加载这些class文件然后运行，
 本文介绍了虚拟机如何加载这些Class文件以及加载到虚拟机中后会发生哪些变化。

 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

# 类加载时机


类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：
1. 加载（Loading）
2. 验证（Verification）
3. 准备（Preparation）
4. 解析（Resolution）
5. 初始化（Initialization）
6. 使用（Using）
7. 卸载（Unloading）

![类的生命周期](/img/post-images/2017-10-15/class_life.png)


其中验证、准备、解析3个部分统称为连接（Linking）.

加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，
而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。

对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：
触发条件：
1. 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。
生成这4条指令的最常见的Java代码场景是：
- 使用new关键字实例化对象的时候
- 读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候
- 以及调用一个类的静态方法的时候。
2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类。
5. 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

# 类加载的过程



## 加载

在加载阶段，虚拟机需要完成以下3件事情：
1）通过一个类的全限定名来获取定义此类的二进制字节流。
2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

注意：非数组类加载过程与数组类加载过程有一定不同：数组类本身不通过类加载器创建，由Java虚拟机直接创建。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口。


## 验证

验证阶段大致上会完成下面4个阶段的检验动作：
1. 文件格式验证：验证字节流是否符合Class文件规范，是否能被当前版本虚拟机处理
2. 元数据验证：对类的元数据信息进行语义校验（如是否有父类，父类是否继承了final类、类中的字段、方法是否与父类矛盾等），保证其描述符合Java语言规范
3. 字节码验证：通过数据流与控制流分析，确定程序语义合法、合逻辑。检查Class文件中的方法体中“StackMapTable”属性中记录是否合法
4. 符号引用验证：在虚拟机将符号引用转换成直接引用（解析阶段执行）时，对类自身之外的信息（如是否能根据字符串描述的全限定名找到对应的类，类中是否存在正确的字段描述符、符号引用中的类、字段、方法的可访问性等）进行匹配性校验

注意：验证阶段虽然重要，但是不是必须的。可通过-Xverify:none 关闭，来缩短虚拟机类加载的时间


## 准备

该阶段为类变量分配内存并设置初始值，如 定义了一个

```
public static int value = 123;

```
那么该阶段进行初始化的结果是value=0（注意final除外，final修饰后，在该阶段直接赋值123）

![基本数据类型初始值](/img/post-images/2017-10-15/initialValue.png)


## 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程

符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。

直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info 7种常量类型

## 初始化

初始化阶段是执行类构造器＜clinit＞（）方法的过程

＜clinit＞（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问

＜clinit＞（）方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成＜clinit＞（）方法。

# 类加载器

“通过一个类的全限定名来获取描述此类的二进制字节流”让应用程序自己决定如何去获取所需要的类，实现这个动作的代码模块称为“类加载器”

## 类与类加载器

对于任意一个类，都需要由加载它的类加载器以及这个类本身确定其在Java虚拟机中的唯一性（因为类加载器额能不止一个，我们可以自行实现）

## 双亲委派模型（Parents Delegation Model ）

这个是类加载器之间的一种层次关系，如下图所示，该模型要求除了顶层的启动类加载器外，其他的类加载器都应当有自己的父类加载器。类加载器之间父子关系一般以**组合关系**来实现,而非继承关系。

![类加载器双亲委派模型](/img/post-images/2017-10-15/parents_delegation_model.png)


双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。

## 破坏双亲委派模型

- 基础类需要回调用户代码

如JNDI可以对资源进行集中管理与查找，但是需要调用JNDI接口提供者的代码

采用线程上下文类加载器（Thread Context ClassLoader）：这个类加载器可以通过java.lang.Thread类的setContextClassLoaser（）方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。

- 程序动态性需要

如代码热替换（HotSwap）、模块热部署等

模块化OSGI（模块化热部署的关键是自定义类加载器机制实现，类加载器为网状结构）以及JDK1.9支持的Jigsaw项目等

# 总结

虚拟机加载的class文件并非特指磁盘的文件，而应该是一串二进制字节流（可能来自网络，可能仅在内存中存在也可能是其他运行于JVM虚拟机的语言生成的文件后缀，但是遵循class文件的格式）。

本文为学习笔记型记录，很多内容不是很详细，可参考文章末尾的参考资料以及JAVA虚拟机规范进行深入阅读

# 参考资料

深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）
